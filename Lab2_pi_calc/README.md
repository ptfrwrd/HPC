# Вычисление числа пи методом Монте-Карло

- Реализованы функции на GPU/CPU;

- GPU: используется pycuda ->  SourceModule содержит реализацию алгоритма на GPU:
-     Есть две последовательности: x, y ; -> 
      Считаем temp = x^2 + y^2; -> 
      Если temp < 1 , то возвращаем 1 (к счётчику прибавляем 1), иначе возвращаем 0 (оставляем значение счётчика без изменений); -> 
      Выполняется атомарная операция сложения; ->
      Домножение на 4/n будет осуществлено позже.
      Размер блока: (128,1,1), т.к. массивы одномерные;
      Размер грида: (int(n/(128 * block[0])), 1)
      
- CPU: алгоритм такой же, как у GPU, домножение осуществляется в цикле.

- Генерация данных: в условиях лабораторной работы требуется генерировать данные  CURAND, поэтому массивы x, y и result_gpu генерируются следующим образом:
-     x_gpu = curand((n,), dtype=np.double) 
      x = x_gpu.get().astype(np.double)
      Функцией get() получаем ndarray массив, который можно использовать как и для GPU, так и для CPU.
      Указывается явно dtype=np.double (т.к. при передаче в GPU функцию SourceModule указан тип double *a, иначе получится неверный результат)
      Также проверяется введенное число n на кратность 16.
      
- Произведены замеры времени и сравнение с числом пи, предоставленым библиотекой numpy:

<table>
<thead>
<tr><th>n</th><th>CPU время</th><th>GPU время</th><th>Ускорение</th><th>pi Монте-Карло</th><th>|pi Монте-Карло - numpy pi|</th></tr>
</thead>
<tbody>
<tr><td>1048576</td><td> 0.4175</td><td>0.0139</td><td>30.0748</td><td>3.143840789794922</td><td>0.002248136205128759</td></tr>
<tr><td>16777216</td><td>6.0504</td><td>0.1364</td><td>44.343</td><td>3.1416118144989014</td><td>1.916090910825119e-05</td></tr>
<tr><td>268435456</td><td>101.0558</td><td> 1.4839</td><td>68.1035</td><td>3.1415569186210632</td><td>3.5734968729883576e-05</td></tr>
</tbody>
</table>
